<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>From MVC to MVVM: a clean refactor plan - Code Journey</title>
    <link rel="stylesheet" href="../styles.css" />
    <link rel="stylesheet" href="../post-styles.css" />
  </head>
  <body>
    <header class="post-header">
      <nav class="nav">
        <div class="brand">
          <a href="../index.html" class="brand-link">
            <span class="brand-mark"></span>
            <div class="brand-text">
              <p class="brand-title">Code Journey</p>
              <p class="brand-subtitle">iOS Developer ¬∑ Blog & Portfolio</p>
            </div>
          </a>
        </div>
        <div class="nav-actions">
          <button class="ghost-button" type="button" onclick="window.location.href='../index.html#settings'">Subscribe</button>
          <button class="secondary-button" type="button" onclick="window.location.href='../index.html'">Back to Blog</button>
        </div>
      </nav>
    </header>

    <article class="post-content">
      <div class="post-hero">
        <div class="post-meta-header">
          <span class="pill">Architecture</span>
          <span class="post-date">June 20, 2024</span>
          <span class="read-time">5 min read</span>
        </div>
        <h1>From MVC to MVVM: a clean refactor plan</h1>
        <p class="post-subtitle">
          The checkpoints I follow to refactor existing apps without breaking shipping schedules.
        </p>
      </div>

      <div class="post-body">
        <h2>Why Refactor to MVVM?</h2>
        <p>
          MVC (Model-View-Controller) has served iOS developers well for years, butViewController bloat is real. When you're dealing with 1000+ line ViewControllers that handle business logic, networking, AND UI updates, it's time to consider MVVM.
        </p>

        <h2>The Refactor Strategy</h2>
        <p>
          The key to successful refactoring is doing it incrementally. Here's my step-by-step process that keeps the app shippable at every stage:
        </p>

        <h3>Phase 1: Identify a Single Screen</h3>
        <p>
          Don't try to refactor your entire app at once. Pick one problematic screen‚Äîideally one with:
        </p>
        <ul>
          <li>Lots of business logic</li>
          <li>Network calls</li>
          <li>Complex state management</li>
        </ul>

        <h3>Phase 2: Extract the ViewModel</h3>
        <p>
          Start by creating a ViewModel class. Here's the structure I use:
        </p>

        <pre><code>class ProfileViewModel {
    // MARK: - Published Properties
    @Published var username: String = ""
    @Published var profileImage: UIImage?
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    
    // MARK: - Dependencies
    private let userService: UserServiceProtocol
    private var cancellables = Set<AnyCancellable>()
    
    init(userService: UserServiceProtocol = UserService()) {
        self.userService = userService
    }
    
    // MARK: - Public Methods
    func loadProfile() {
        isLoading = true
        userService.fetchProfile()
            .sink { [weak self] completion in
                self?.isLoading = false
                if case .failure(let error) = completion {
                    self?.errorMessage = error.localizedDescription
                }
            } receiveValue: { [weak self] profile in
                self?.username = profile.name
                self?.profileImage = profile.image
            }
            .store(in: &cancellables)
    }
}</code></pre>

        <h3>Phase 3: Move Business Logic</h3>
        <p>
          Systematically move logic from the ViewController to the ViewModel. I look for:
        </p>
        <ul>
          <li>Data transformations</li>
          <li>Validation logic</li>
          <li>Network call coordination</li>
          <li>State management</li>
        </ul>

        <pre><code>// ‚ùå Before - in ViewController
func validateUsername() {
    if usernameTextField.text?.count ?? 0 < 3 {
        errorLabel.text = "Username too short"
        submitButton.isEnabled = false
    } else {
        errorLabel.text = nil
        submitButton.isEnabled = true
    }
}

// ‚úÖ After - in ViewModel
func validate(username: String) -> Bool {
    return username.count >= 3
}

var isValid: Bool {
    validate(username: username)
}</code></pre>

        <h3>Phase 4: Set Up Bindings</h3>
        <p>
          This is where Combine shines. Set up publishers in the ViewController:
        </p>

        <pre><code>class ProfileViewController: UIViewController {
    private let viewModel = ProfileViewModel()
    private var cancellables = Set<AnyCancellable>()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupBindings()
        viewModel.loadProfile()
    }
    
    private func setupBindings() {
        viewModel.$username
            .sink { [weak self] username in
                self?.usernameLabel.text = username
            }
            .store(in: &cancellables)
        
        viewModel.$isLoading
            .sink { [weak self] isLoading in
                self?.activityIndicator.isHidden = !isLoading
            }
            .store(in: &cancellables)
    }
}</code></pre>

        <h2>Common Pitfalls</h2>

        <h3>1. ViewModels Knowing About Views</h3>
        <p>
          Never import UIKit in your ViewModel (except for UIImage if necessary). If you find yourself accessing UIView properties, rethink your approach.
        </p>

        <h3>2. Massive ViewModels</h3>
        <p>
          Just because you extracted code from the ViewController doesn't mean you solved the problem. If your ViewModel is 800 lines, you need to break it down further‚Äîconsider separate service classes.
        </p>

        <h3>3. Not Testing</h3>
        <p>
          One of MVVM's biggest benefits is testability. Write unit tests for your ViewModels:
        </p>

        <pre><code>func testLoadProfile_Success() {
    let mockService = MockUserService()
    let viewModel = ProfileViewModel(userService: mockService)
    
    viewModel.loadProfile()
    
    XCTAssertEqual(viewModel.username, "Test User")
    XCTAssertFalse(viewModel.isLoading)
    XCTAssertNil(viewModel.errorMessage)
}</code></pre>

        <h2>Results</h2>
        <p>
          After refactoring three major screens in my app:
        </p>
        <ul>
          <li>Average ViewController size dropped from 650 to 180 lines</li>
          <li>Unit test coverage increased from 12% to 67%</li>
          <li>Onboarding new developers became significantly easier</li>
        </ul>

        <h2>Should You Refactor to MVVM?</h2>
        <p>
          If you're building a SwiftUI app, you're already using something close to MVVM with <code>@StateObject</code> and <code>ObservableObject</code>. If you're maintaining UIKit code, MVVM is worth considering‚Äîbut only if the pain of MVC exceeds the cost of refactoring.
        </p>

        <div class="share-section">
          <h3>Share this article</h3>
          <div class="share-buttons">
            <a href="https://twitter.com/intent/tweet?text=From%20MVC%20to%20MVVM:%20a%20clean%20refactor%20plan&url=" class="share-button twitter" target="_blank">
              <span>üê¶</span>
              Share on Twitter
            </a>
            <a href="https://www.linkedin.com/sharing/share-offsite/?url=" class="share-button linkedin" target="_blank">
              <span>üíº</span>
              Share on LinkedIn
            </a>
            <button class="share-button copy" onclick="navigator.clipboard.writeText(window.location.href); this.textContent = '‚úì Copied!'">
              <span>üîó</span>
              Copy Link
            </button>
          </div>
        </div>

        <div class="author-section">
          <div class="author-avatar">CH</div>
          <div class="author-info">
            <h4>Connor Hill</h4>
            <p>
              iOS developer passionate about crafting delightful mobile experiences. 
              I write about SwiftUI, UIKit, and everything in between. 
              Currently building apps that prioritize performance and user experience.
            </p>
          </div>
        </div>

        <div class="post-footer-cta">
          <h3>Interested in more architecture content?</h3>
          <p>Subscribe to get my latest posts on iOS architecture and best practices.</p>
          <button class="primary-button" onclick="window.location.href='../index.html#settings'">
            Subscribe to Newsletter
          </button>
        </div>

        <!-- Comments Section -->
        <div id="postComments" class="post-comments-section" data-post-id="mvc-to-mvvm-refactor">
          <h3 style="margin: 0 0 8px 0; color: var(--text-primary);">
            Comments (<span id="commentsCount">0</span>)
          </h3>
          <p class="muted" style="margin-bottom: 24px;">Share your thoughts and experiences with this topic.</p>
          
          <div id="commentFormContainer"></div>
          <div id="commentsList" class="comment-list"></div>
        </div>
      </div>
    </article>

    <script type="module" src="../js/post-comments.js"></script>

    <footer class="footer">
      <div class="footer-content">
        <div>
          <p class="footer-title">Code Journey</p>
          <p>¬© 2026 Connor Hill. All rights reserved.</p>
          <p class="footer-subtitle">Building delightful iOS experiences.</p>
        </div>
        <div class="footer-links">
          <div class="footer-section">
            <h4>Connect</h4>
            <a href="#" class="link-button">LinkedIn</a>
            <a href="#" class="link-button">GitHub</a>
            <a href="#" class="link-button">Twitter</a>
            <a href="mailto:hello@codejourney.dev" class="link-button">Email</a>
          </div>
          <div class="footer-section">
            <h4>Navigate</h4>
            <a href="../index.html#blogs" class="link-button">Blog</a>
            <a href="../index.html#portfolio" class="link-button">Portfolio</a>
            <a href="../index.html#about" class="link-button">About</a>
            <a href="../index.html#settings" class="link-button">Subscribe</a>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>
